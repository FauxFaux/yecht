/* Generated by re2j 0.13.6.dev on Fri Jul 24 16:27:32 2009 */
package org.yecht;

import java.io.IOException;

// Equivalent to token.re
public class TokenScanner implements DefaultYAMLParser.yyInput {
   public final static int QUOTELEN = 1024;
   private Parser parser;

   private Object lval;
   private int currentToken = -1;

   public static void error(String msg, Parser parser) {
       if(parser.error_handler == null) {
           parser.error_handler = new ErrorHandler.Default();
       }
       parser.root = parser.root_on_error;
       parser.error_handler.handle(parser, msg);
   }

   public static DefaultYAMLParser.yyInput createScanner(Parser parser) {
     switch(parser.input_type) {
       case YAML_UTF8:
         return new TokenScanner(parser);
       case Bytecode_UTF8:
         return new BytecodeScanner(parser);
       case YAML_UTF16:
         error("UTF-16 is not currently supported in Yecht.\nPlease contribute code to help this happen!", parser);
         return null;
       case YAML_UTF32:
         error("UTF-32 is not currently supported in Yecht.\nPlease contribute code to help this happen!", parser);
         return null;
     }
     return null;
   }

   public TokenScanner(Parser parser) {
     this.parser = parser;
   }

   public Object value() {
     return lval;
   }

   public int token() {
     return currentToken;
   }

   public boolean advance() throws java.io.IOException {
     currentToken = real_yylex();
     return currentToken == 0 ? false : true;
   }

   private int isNewline(int ptr) {
     return newlineLen(ptr);
   }

   private int newlineLen(int ptr) {
     if(parser.buffer.buffer[ptr] == '\n')
       return 1;

     if(parser.buffer.buffer[ptr] == '\r' && parser.buffer.buffer[ptr+1] == '\n')
       return 2;
       
     return 0;
   }

   private int isNewline(byte[] buff, int ptr) {
     return newlineLen(buff, ptr);
   }

   private int newlineLen(byte[] buff, int ptr) {
     if(buff[ptr] == '\n')
       return 1;

     if(buff[ptr] == '\r' && buff[ptr+1] == '\n')
       return 2;
       
     return 0;
   }

   private void NEWLINE(int ptr) {
     parser.lineptr = ptr + newlineLen(ptr);
     if(parser.lineptr > parser.linectptr) {
       parser.linect++;
       parser.linectptr = parser.lineptr;
     }
   }

   private void RETURN_YAML_BLOCK(QuotedString q, int blockType, int nlDoWhat) {
       Node n = Node.allocStr();
       if(parser.taguri_expansion) {
           n.type_id = Parser.taguri(YAML.DOMAIN, "str");
       } else {
           n.type_id = "str";
       }

       Data.Str dd = (Data.Str)n.data;
       dd.ptr = Pointer.create(q.str, 0);
       dd.len = q.idx;
       if(blockType == YAML.BLOCK_LIT) {
           dd.style = ScalarStyle.Literal;
       } else {
           dd.style = ScalarStyle.Fold;
       }
       if(q.idx > 0) {
           if(nlDoWhat != YAML.NL_KEEP) {
               int fc = dd.len - 1;
               while(isNewline(dd.ptr.buffer, fc) > 0) {
                   fc--;
               }
               if(nlDoWhat != YAML.NL_CHOMP && fc < (dd.len-1)) {
                   fc += 1;
               }
               dd.len = fc + 1;
           }
       }
       lval = n;
   }

   private int GET_TRUE_YAML_INDENT() {
       Level lvl_deep = parser.currentLevel();
       int indt_len = lvl_deep.spaces;
       if(lvl_deep.status == LevelStatus.seq || (indt_len == parser.cursor - parser.lineptr && lvl_deep.status != LevelStatus.map)) {
            parser.lvl_idx--;
            Level lvl_over = parser.currentLevel();
            indt_len = lvl_over.spaces;
            parser.lvl_idx++;
        }

        return indt_len;       
   }
   
   public final static String[] tnames = new String[126];
   static {
       tnames[0] = "ENDINPUT";
       tnames[1] = "ALIAS";
       tnames[2] = "ANCHOR";
       tnames[3] = "BLOCK";
       tnames[4] = "DOCSEP";
       tnames[5] = "IEND";
       tnames[6] = "INDENT";
       tnames[7] = "IOPEN";
       tnames[8] = "ITRANSFER";
       tnames[9] = "PLAIN";
       tnames[10] = "TAGURI";
       tnames[11] = "TRANSFER";
       tnames[12] = "WORD";
       tnames[13] = "error";
       tnames[44] = "COMMA";
       tnames[45] = "DASH";
       tnames[58] = "COLON";
       tnames[63] = "QUESTION";
       tnames[91] = "SQUAREO";
       tnames[93] = "SQUAREC";
       tnames[123] = "CURLYO";
       tnames[125] = "CURLYC";
   }

   private void YYPOS(int n) {
       parser.cursor = parser.token + n;
   }

   private static class QuotedString {
       public int idx = 0;
       public int capa = 100;
       public byte[] str;

       public QuotedString() {
           str = new byte[100];
       }

       public void cat(char l) {
           cat((byte)l);
       }
      
       public void cat(byte l) {
           if(idx + 1 >= capa) {
               capa += QUOTELEN;
               str = YAML.realloc(str, capa);
           }
           str[idx++] = l;
           str[idx] = 0;
       }

       public void cat(byte[] l, int cs, int cl) {
           while(idx + cl >= capa) {
               capa += QUOTELEN;
               str = YAML.realloc(str, capa);
           }
           System.arraycopy(l, cs, str, idx, cl);
           idx += cl;
           str[idx] = 0;
       }

       public void plain_is_inl() {
           int walker = idx - 1;
           while(walker > 0 && (str[walker] == '\n' || str[walker] == ' ' || str[walker] == '\t')) {
               idx--;
               str[walker] = 0;
               walker--;
          }
       }
   }

   public void RETURN_IMPLICIT(QuotedString q) {
       Node n = Node.allocStr();
       parser.cursor = parser.token;
       Data.Str dd = (Data.Str)n.data;
       dd.ptr = Pointer.create(q.str, 0);
       dd.len = q.idx;
       dd.style = ScalarStyle.Plain;                            
       lval = n;
       if(parser.implicit_typing) {
           ImplicitScanner.tryTagImplicit(n, parser.taguri_expansion);
       }
   }

    private int real_yylex() throws IOException {
        if(parser.cursor == -1) {
            parser.read();
        }

//     System.err.println("real_yylex(" + new String(parser.buffer.buffer, parser.buffer.start, parser.bufsize) + ")");
//        System.out.println("real_yylex()");
        if(parser.force_token != 0) {
            int t = parser.force_token;
            parser.force_token = 0;
            return t;
        }



        if(parser.lineptr != parser.cursor) {
            return document(0);
        } else {
            return header();
        }
    }

    private int header() throws java.io.IOException {
//        System.out.println("header()");
        Level lvl;
        int doc_level = 0;
        while(true) {
            parser.token = parser.cursor;

        int gotoPoint = -1;
        byte yych = (byte) 0;
        int yyaccept = 0;
        gotoNext: while(gotoPoint != -2) {
            int currentGoto = gotoPoint; gotoPoint = -2;
            switch(currentGoto) {
            case -1: 

                if ((parser.limit - parser.cursor) < 5) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case 0x00:    {gotoPoint = 7; continue gotoNext;}
                case '\t':
                case ' ':    {gotoPoint = 12; continue gotoNext;}
                case '\n':    {gotoPoint = 9; continue gotoNext;}
                case '\r':    {gotoPoint = 11; continue gotoNext;}
                case '#':    {gotoPoint = 5; continue gotoNext;}
                case '-':    {gotoPoint = 2; continue gotoNext;}
                case '.':    {gotoPoint = 4; continue gotoNext;}
                default:    {gotoPoint = 14; continue gotoNext;}
                }
            case 2:
                yyaccept = 0;
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                switch (yych) {
                case '-':    {gotoPoint = 28; continue gotoNext;}
                default:    {gotoPoint = 3; continue gotoNext;}
                }
            case 3:
                {   YYPOS(0);
                        return document(doc_level);
                    }
            case 4:
                yyaccept = 0;
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                switch (yych) {
                case '.':    {gotoPoint = 21; continue gotoNext;}
                default:    {gotoPoint = 3; continue gotoNext;}
                }
            case 5:
                ++parser.cursor;
                {   
                        eatComments(); 
                        break;
                    }
            case 7:
                ++parser.cursor;
                {   lvl = parser.currentLevel();
                        if(lvl.spaces > -1) {
                            parser.popLevel();
                            YYPOS(0);
                            return DefaultYAMLParser.YAML_IEND;
                        }
                        YYPOS(0);
                        return 0; 
                    }
            case 9:
                yyaccept = 1;
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                {gotoPoint = 18; continue gotoNext;}
            case 10:
                {
                        int indent = parser.token;
                        NEWLINE(indent);
                        while(indent < parser.cursor) {
                            // these pieces commented out to be compatible with Syck 0.60. 
//                          if(parser.buffer.buffer[indent] == '\t') {
//                            error("TAB found in your indentation, please remove",parser);
//                          } else if(isNewline(++indent) != 0) {
//                            NEWLINE(indent);
//                          }

                          if(isNewline(++indent) != 0) {
                            NEWLINE(indent);
                          }
                        }
                        doc_level = 0;
                        if(parser.buffer.buffer[parser.cursor] == 0) {
                          doc_level = -1;
                          parser.token = parser.cursor-1;
                        } else if(parser.buffer.buffer[parser.lineptr] == ' ') {
                          doc_level = parser.cursor - parser.lineptr;
                        }
                        break;
                    }
            case 11:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 17; continue gotoNext;}
                default:    {gotoPoint = 3; continue gotoNext;}
                }
            case 12:
                ++parser.cursor;
                yych = parser.buffer.buffer[parser.cursor];
                {gotoPoint = 16; continue gotoNext;}
            case 13:
                {   doc_level = parser.cursor - parser.lineptr;
                        break;
                    }
            case 14:
                yych = parser.buffer.buffer[++parser.cursor];
                {gotoPoint = 3; continue gotoNext;}
            case 15:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
            case 16:
                switch (yych) {
                case '\t':
                case ' ':    {gotoPoint = 15; continue gotoNext;}
                default:    {gotoPoint = 13; continue gotoNext;}
                }
            case 17:
                yyaccept = 1;
                parser.marker = ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
            case 18:
                switch (yych) {
                case '\n':
                case ' ':    {gotoPoint = 17; continue gotoNext;}
                case '\r':    {gotoPoint = 19; continue gotoNext;}
                default:    {gotoPoint = 10; continue gotoNext;}
                }
            case 19:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 17; continue gotoNext;}
                default:    {gotoPoint = 20; continue gotoNext;}
                }
            case 20:
                parser.cursor = parser.marker;
                if (yyaccept == 0) {
                    {gotoPoint = 3; continue gotoNext;}
                } else {
                    {gotoPoint = 10; continue gotoNext;}
                }
            case 21:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '.':    {gotoPoint = 22; continue gotoNext;}
                default:    {gotoPoint = 20; continue gotoNext;}
                }
            case 22:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 23; continue gotoNext;}
                case '\r':    {gotoPoint = 27; continue gotoNext;}
                case ' ':    {gotoPoint = 25; continue gotoNext;}
                default:    {gotoPoint = 20; continue gotoNext;}
                }
            case 23:
                ++parser.cursor;
            case 24:
                {   lvl = parser.currentLevel();
                        if(lvl.status != LevelStatus.header) {
                          if(lvl.spaces > -1) {
                            parser.popLevel();
                            YYPOS(0);
                            return DefaultYAMLParser.YAML_IEND;
                          }
                          YYPOS(0);
                          return 0; 
                        }
                        break;
                    }
            case 25:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case ' ':    {gotoPoint = 25; continue gotoNext;}
                default:    {gotoPoint = 24; continue gotoNext;}
                }
            case 27:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 23; continue gotoNext;}
                default:    {gotoPoint = 20; continue gotoNext;}
                }
            case 28:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '-':    {gotoPoint = 29; continue gotoNext;}
                default:    {gotoPoint = 20; continue gotoNext;}
                }
            case 29:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 30; continue gotoNext;}
                case '\r':    {gotoPoint = 34; continue gotoNext;}
                case ' ':    {gotoPoint = 32; continue gotoNext;}
                default:    {gotoPoint = 20; continue gotoNext;}
                }
            case 30:
                ++parser.cursor;
            case 31:
                { lvl = parser.currentLevel();
                      if(lvl.status == LevelStatus.header) {
                          YYPOS(3);
                          return directive();
                      } else {
                          if(lvl.spaces > -1) {
                              parser.popLevel();
                              YYPOS(0);
                              return DefaultYAMLParser.YAML_IEND;
                          }
                          YYPOS(0);
                          return 0;
                      }
                    }
            case 32:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case ' ':    {gotoPoint = 32; continue gotoNext;}
                default:    {gotoPoint = 31; continue gotoNext;}
                }
            case 34:
                ++parser.cursor;
                switch ((yych = parser.buffer.buffer[parser.cursor])) {
                case '\n':    {gotoPoint = 30; continue gotoNext;}
                default:    {gotoPoint = 20; continue gotoNext;}
                }
            }
        }

        }
    }


    // TODO: implement without re2j
   private int document(int doc_level) throws java.io.IOException {
//        System.out.println("document()");
       while(true) {
           Level lvl = parser.currentLevel();
           if(lvl.status == LevelStatus.header) {
               lvl.status = LevelStatus.doc;
           }

           parser.token = parser.cursor;


        int gotoPoint = -1;
        byte yych = (byte) 0;
        int yyaccept = 0;
        gotoNext: while(gotoPoint != -2) {
            int currentGoto = gotoPoint; gotoPoint = -2;
            switch(currentGoto) {
            case -1: 
                if ((parser.limit - parser.cursor) < 3) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case 0x00:    {gotoPoint = 62; continue gotoNext;}
                case '\t':
                case ' ':    {gotoPoint = 60; continue gotoNext;}
                case '\n':    {gotoPoint = 37; continue gotoNext;}
                case '\r':    {gotoPoint = 39; continue gotoNext;}
                case '!':    {gotoPoint = 51; continue gotoNext;}
                case '"':    {gotoPoint = 55; continue gotoNext;}
                case '#':    {gotoPoint = 58; continue gotoNext;}
                case '&':    {gotoPoint = 49; continue gotoNext;}
                case '\'':    {gotoPoint = 53; continue gotoNext;}
                case '*':    {gotoPoint = 50; continue gotoNext;}
                case ',':
                case ':':    {gotoPoint = 47; continue gotoNext;}
                case '-':
                case '?':    {gotoPoint = 48; continue gotoNext;}
                case '>':
                case '|':    {gotoPoint = 57; continue gotoNext;}
                case '[':    {gotoPoint = 41; continue gotoNext;}
                case ']':
                case '}':    {gotoPoint = 45; continue gotoNext;}
                case '{':    {gotoPoint = 43; continue gotoNext;}
                default:    {gotoPoint = 64; continue gotoNext;}
                }
            case 37:
                yyaccept = 0;
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                {gotoPoint = 92; continue gotoNext;}
            case 38:
                {   /* Isolate spaces */
                        int indt_len;
                        int indent = parser.token;
                        NEWLINE(indent);
                        while(indent < parser.cursor) {
                            // these pieces commented out to be compatible with Syck 0.60. 
//                          if(parser.buffer.buffer[indent] == '\t') {
//                            error("TAB found in your indentation, please remove",parser);
//                          } else if(isNewline(++indent) != 0) {
//                            NEWLINE(indent);
//                          }

                          if(isNewline(++indent) != 0) {
                            NEWLINE(indent);
                          }
                        }
                        indt_len = 0;
                        if(parser.buffer.buffer[parser.cursor] == 0) {
                          indt_len = -1;
                          parser.token = parser.cursor-1;
                        } else if(parser.buffer.buffer[parser.lineptr] == ' ') {
                          indt_len = parser.cursor - parser.lineptr;
                        }

                        lvl = parser.currentLevel();
                        doc_level = 0;

                        /* XXX: Comment lookahead */
                        /* Ignore indentation inside inlines */
                        if(parser.buffer.buffer[parser.cursor] != '#' && lvl.status != LevelStatus.iseq && lvl.status != LevelStatus.imap) {
                            /* Check for open indent */
                            if(lvl.spaces > indt_len) {
                                parser.popLevel();
                                YYPOS(0);
                                return DefaultYAMLParser.YAML_IEND;
                            }
                            if(lvl.spaces < indt_len) {
                                if(lvl.status != LevelStatus.iseq && lvl.status != LevelStatus.imap) {
                                    parser.addLevel(indt_len, LevelStatus.doc);
                                    return DefaultYAMLParser.YAML_IOPEN;
                                }
                            } else {
                                if(indt_len == -1) {
                                    return 0;
                                }
                                return DefaultYAMLParser.YAML_INDENT;
                            }
                        }
                        break;
                    }
            case 39:
                ++parser.cursor;
                switch ((yych = parser.buffer.buffer[parser.cursor])) {
                case '\n':    {gotoPoint = 91; continue gotoNext;}
                default:    {gotoPoint = 40; continue gotoNext;}
                }
            case 40:
                {   
                        if(lvl.spaces < doc_level) {
                            if(lvl.status != LevelStatus.iseq && lvl.status != LevelStatus.imap) {
                                parser.addLevel(doc_level, LevelStatus.doc);
                                YYPOS(0);
                                return DefaultYAMLParser.YAML_IOPEN;
                            }
                        } else {
                            return plain();
                        }
                        break;
                    }
            case 41:
                ++parser.cursor;
                {   
                        if(lvl.spaces < doc_level) {
                            if(lvl.status != LevelStatus.iseq && lvl.status != LevelStatus.imap) {
                                parser.addLevel(doc_level, LevelStatus.doc);
                                YYPOS(0);
                                return DefaultYAMLParser.YAML_IOPEN;
                            }
                        } else {
                            lvl = parser.currentLevel();
                            parser.addLevel(lvl.spaces + 1, LevelStatus.iseq);
                            return parser.buffer.buffer[parser.token];
                        }
                        break;                    
                    }
            case 43:
                ++parser.cursor;
                {
                        if(lvl.spaces < doc_level) {
                            if(lvl.status != LevelStatus.iseq && lvl.status != LevelStatus.imap) {
                                parser.addLevel(doc_level, LevelStatus.doc);
                                YYPOS(0);
                                return DefaultYAMLParser.YAML_IOPEN;
                            }
                        } else {
                            lvl = parser.currentLevel();
                            parser.addLevel(lvl.spaces + 1, LevelStatus.imap);
                            return parser.buffer.buffer[parser.token];
                        }
                        break;
                    }
            case 45:
                ++parser.cursor;
                {   parser.popLevel();
                        return parser.buffer.buffer[parser.token];
                    }
            case 47:
                yyaccept = 1;
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                switch (yych) {
                case '\n':    {gotoPoint = 86; continue gotoNext;}
                case '\r':    {gotoPoint = 90; continue gotoNext;}
                case ' ':    {gotoPoint = 88; continue gotoNext;}
                default:    {gotoPoint = 40; continue gotoNext;}
                }
            case 48:
                yyaccept = 1;
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                switch (yych) {
                case '\n':    {gotoPoint = 81; continue gotoNext;}
                case '\r':    {gotoPoint = 85; continue gotoNext;}
                case ' ':    {gotoPoint = 83; continue gotoNext;}
                default:    {gotoPoint = 40; continue gotoNext;}
                }
            case 49:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '-':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '_':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':    {gotoPoint = 78; continue gotoNext;}
                default:    {gotoPoint = 40; continue gotoNext;}
                }
            case 50:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '-':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '_':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':    {gotoPoint = 75; continue gotoNext;}
                default:    {gotoPoint = 40; continue gotoNext;}
                }
            case 51:
                ++parser.cursor;
                {   return transferMethod(); }
            case 53:
                ++parser.cursor;
                {   
                        if(lvl.spaces < doc_level) {
                            if(lvl.status != LevelStatus.iseq && lvl.status != LevelStatus.imap) {
                                parser.addLevel(doc_level, LevelStatus.doc);
                                YYPOS(0);
                                return DefaultYAMLParser.YAML_IOPEN;
                            }
                        } else {
                            return singleQuote(); 
                        }
                        break;
                    }
            case 55:
                ++parser.cursor;
                {   
                        if(lvl.spaces < doc_level) {
                            if(lvl.status != LevelStatus.iseq && lvl.status != LevelStatus.imap) {
                                parser.addLevel(doc_level, LevelStatus.doc);
                                YYPOS(0);
                                return DefaultYAMLParser.YAML_IOPEN;
                            }
                        } else {
                            return doubleQuote();
                        }
                        break;
                    }
            case 57:
                yyaccept = 1;
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                switch (yych) {
                case '\n':    {gotoPoint = 70; continue gotoNext;}
                case '\r':    {gotoPoint = 74; continue gotoNext;}
                case ' ':    {gotoPoint = 72; continue gotoNext;}
                case '+':
                case '-':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':    {gotoPoint = 67; continue gotoNext;}
                default:    {gotoPoint = 40; continue gotoNext;}
                }
            case 58:
                ++parser.cursor;
                {   
                        eatComments(); 
                        break;
                    }
            case 60:
                ++parser.cursor;
                yych = parser.buffer.buffer[parser.cursor];
                {gotoPoint = 66; continue gotoNext;}
            case 61:
                {
                        break;
                    }
            case 62:
                ++parser.cursor;
                {   
                        if(lvl.spaces > -1) {
                            parser.popLevel();
                            YYPOS(0);
                            return DefaultYAMLParser.YAML_IEND;
                        }
                        YYPOS(0);
                        return 0; 
                    }
            case 64:
                yych = parser.buffer.buffer[++parser.cursor];
                {gotoPoint = 40; continue gotoNext;}
            case 65:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
            case 66:
                switch (yych) {
                case '\t':
                case ' ':    {gotoPoint = 65; continue gotoNext;}
                default:    {gotoPoint = 61; continue gotoNext;}
                }
            case 67:
                ++parser.cursor;
                if ((parser.limit - parser.cursor) < 2) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 70; continue gotoNext;}
                case '\r':    {gotoPoint = 74; continue gotoNext;}
                case ' ':    {gotoPoint = 72; continue gotoNext;}
                case '+':
                case '-':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':    {gotoPoint = 67; continue gotoNext;}
                default:    {gotoPoint = 69; continue gotoNext;}
                }
            case 69:
                parser.cursor = parser.marker;
                if (yyaccept == 0) {
                    {gotoPoint = 38; continue gotoNext;}
                } else {
                    {gotoPoint = 40; continue gotoNext;}
                }
            case 70:
                ++parser.cursor;
            case 71:
                {   if(isNewline(parser.cursor - 1) != 0) {
                            parser.cursor--;
                        }
                        return scalarBlock();
                    }
            case 72:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case ' ':    {gotoPoint = 72; continue gotoNext;}
                default:    {gotoPoint = 71; continue gotoNext;}
                }
            case 74:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 70; continue gotoNext;}
                default:    {gotoPoint = 69; continue gotoNext;}
                }
            case 75:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case '-':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '_':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':    {gotoPoint = 75; continue gotoNext;}
                default:    {gotoPoint = 77; continue gotoNext;}
                }
            case 77:
                {   
                        if(lvl.spaces < doc_level) {
                            if(lvl.status != LevelStatus.iseq && lvl.status != LevelStatus.imap) {
                                parser.addLevel(doc_level, LevelStatus.doc);
                                YYPOS(0);
                                return DefaultYAMLParser.YAML_IOPEN;
                            }
                        } else {
                            lval = new String(parser.buffer.buffer, parser.token + 1, parser.cursor - (parser.token + 1), "ISO-8859-1");
                            return DefaultYAMLParser.YAML_ALIAS;
                        }
                        break;
                    }
            case 78:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case '-':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '_':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':    {gotoPoint = 78; continue gotoNext;}
                default:    {gotoPoint = 80; continue gotoNext;}
                }
            case 80:
                {   lval = new String(parser.buffer.buffer, parser.token + 1, parser.cursor - (parser.token + 1), "ISO-8859-1");

                        /*
                         * Remove previous anchors of the same name.  Since the parser will likely
                         * construct deeper nodes first, we want those nodes to be placed in the
                         * queue for matching at a higher level of indentation.
                         */
                        parser.removeAnchor((String)lval);
                        return DefaultYAMLParser.YAML_ANCHOR;
                    }
            case 81:
                ++parser.cursor;
            case 82:
                {   
                        if(lvl.spaces < (parser.token - parser.lineptr)) {
                            if(lvl.status != LevelStatus.iseq && lvl.status != LevelStatus.imap) {
                                parser.addLevel((parser.token - parser.lineptr), LevelStatus.doc);
                                YYPOS(0);
                                return DefaultYAMLParser.YAML_IOPEN;
                            }
                        } else {
                            parser.force_token = DefaultYAMLParser.YAML_IOPEN;
                            if( parser.buffer.buffer[parser.cursor] == '#' || isNewline(parser.cursor) != 0 || isNewline(parser.cursor-1) != 0) {
                                parser.cursor--;
                                parser.addLevel(parser.token + 1 - parser.lineptr, LevelStatus.seq);
                            } else /* spaces followed by content uses the space as indentation */
                            {
                                parser.addLevel(parser.cursor - parser.lineptr, LevelStatus.seq);
                            }
                            return parser.buffer.buffer[parser.token];
                        }
                        break;
                    }
            case 83:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case ' ':    {gotoPoint = 83; continue gotoNext;}
                default:    {gotoPoint = 82; continue gotoNext;}
                }
            case 85:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 81; continue gotoNext;}
                default:    {gotoPoint = 69; continue gotoNext;}
                }
            case 86:
                ++parser.cursor;
            case 87:
                {   if( parser.buffer.buffer[parser.token] == ':' && lvl.status != LevelStatus.imap && lvl.status != LevelStatus.iseq ) {
                            lvl.status = LevelStatus.map;
                        }
                        YYPOS(1); 
                        return parser.buffer.buffer[parser.token];
                    }
            case 88:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case ' ':    {gotoPoint = 88; continue gotoNext;}
                default:    {gotoPoint = 87; continue gotoNext;}
                }
            case 90:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 86; continue gotoNext;}
                default:    {gotoPoint = 69; continue gotoNext;}
                }
            case 91:
                yyaccept = 0;
                parser.marker = ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
            case 92:
                switch (yych) {
                case '\n':
                case ' ':    {gotoPoint = 91; continue gotoNext;}
                case '\r':    {gotoPoint = 93; continue gotoNext;}
                default:    {gotoPoint = 38; continue gotoNext;}
                }
            case 93:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 91; continue gotoNext;}
                default:    {gotoPoint = 69; continue gotoNext;}
                }
            }
        }

       }
   }

   private int directive() throws java.io.IOException {
//        System.out.println("directive()");
       while(true) {
           parser.toktmp = parser.cursor;

        int gotoPoint = -1;
        byte yych = (byte) 0;
        gotoNext: while(gotoPoint != -2) {
            int currentGoto = gotoPoint; gotoPoint = -2;
            switch(currentGoto) {
            case -1: 
                if ((parser.limit - parser.cursor) < 2) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case 0x00:    {gotoPoint = 96; continue gotoNext;}
                case '\t':
                case ' ':    {gotoPoint = 99; continue gotoNext;}
                case '%':    {gotoPoint = 97; continue gotoNext;}
                default:    {gotoPoint = 101; continue gotoNext;}
                }
            case 96:
                parser.cursor = parser.marker;
                {gotoPoint = 98; continue gotoNext;}
            case 97:
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                switch (yych) {
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case ';':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':    {gotoPoint = 104; continue gotoNext;}
                default:    {gotoPoint = 98; continue gotoNext;}
                }
            case 98:
                {   parser.cursor = parser.toktmp;
                        return DefaultYAMLParser.YAML_DOCSEP;
                    }
            case 99:
                ++parser.cursor;
                yych = parser.buffer.buffer[parser.cursor];
                {gotoPoint = 103; continue gotoNext;}
            case 100:
                {  break; }
            case 101:
                yych = parser.buffer.buffer[++parser.cursor];
                {gotoPoint = 98; continue gotoNext;}
            case 102:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
            case 103:
                switch (yych) {
                case '\t':
                case ' ':    {gotoPoint = 102; continue gotoNext;}
                default:    {gotoPoint = 100; continue gotoNext;}
                }
            case 104:
                ++parser.cursor;
                if ((parser.limit - parser.cursor) < 2) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ';':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':    {gotoPoint = 104; continue gotoNext;}
                case ':':    {gotoPoint = 106; continue gotoNext;}
                default:    {gotoPoint = 96; continue gotoNext;}
                }
            case 106:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case ';':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':    {gotoPoint = 107; continue gotoNext;}
                default:    {gotoPoint = 96; continue gotoNext;}
                }
            case 107:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case '.':
                case '/':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case ':':
                case ';':
                case '<':
                case '=':
                case '>':
                case '?':
                case '@':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case '[':
                case '\\':
                case ']':
                case '^':
                case '_':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':    {gotoPoint = 107; continue gotoNext;}
                default:    {gotoPoint = 109; continue gotoNext;}
                }
            case 109:
                {  break; }
            }
        }

       }
   }

   private int plain() throws java.io.IOException {
//        System.out.println("plain()");
       QuotedString q = new QuotedString();

       parser.cursor = parser.token;
       Level plvl = parser.currentLevel();

       Level lvl_deep = parser.currentLevel();
       int parentIndent = lvl_deep.spaces;
       if(lvl_deep.status == LevelStatus.seq || ((parentIndent == parser.cursor - parser.lineptr) && lvl_deep.status != LevelStatus.map)) {
           parser.lvl_idx--;
           Level lvl_over = parser.currentLevel();
           parentIndent = lvl_over.spaces;
           parser.lvl_idx++;
       }

       boolean plain3 = false;

       while(true) {
           parser.token = parser.cursor;
           do {
               plain3 = false;

        int gotoPoint = -1;
        byte yych = (byte) 0;
        int yyaccept = 0;
        gotoNext: while(gotoPoint != -2) {
            int currentGoto = gotoPoint; gotoPoint = -2;
            switch(currentGoto) {
            case -1: 
                if ((parser.limit - parser.cursor) < 3) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case 0x00:    {gotoPoint = 124; continue gotoNext;}
                case '\t':    {gotoPoint = 126; continue gotoNext;}
                case '\n':    {gotoPoint = 112; continue gotoNext;}
                case '\r':    {gotoPoint = 114; continue gotoNext;}
                case ' ':    {gotoPoint = 122; continue gotoNext;}
                case ',':    {gotoPoint = 117; continue gotoNext;}
                case ':':    {gotoPoint = 116; continue gotoNext;}
                case ']':    {gotoPoint = 120; continue gotoNext;}
                case '}':    {gotoPoint = 118; continue gotoNext;}
                default:    {gotoPoint = 127; continue gotoNext;}
                }
            case 112:
                yyaccept = 0;
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                {gotoPoint = 142; continue gotoNext;}
            case 113:
                {   
                        int indt_len, nl_count = 0;
                        int tok = parser.token;
                        int indent = tok;
                        NEWLINE(indent);
                        while(indent < parser.cursor) {
                            // these pieces commented out to be compatible with Syck 0.60. 
//                          if(parser.buffer.buffer[indent] == '\t') {
//                            error("TAB found in your indentation, please remove",parser);
//                          } else if(isNewline(++indent) != 0) {
//                            NEWLINE(indent);
//                          }

                          if(isNewline(++indent) != 0) {
                            NEWLINE(indent);
                          }
                        }
                        indt_len = 0;
                        if(parser.buffer.buffer[parser.cursor] == 0) {
                          indt_len = -1;
                          tok = parser.cursor-1;
                        } else if(parser.buffer.buffer[parser.lineptr] == ' ') {
                          indt_len = parser.cursor - parser.lineptr;
                        }

                        if(indt_len <= parentIndent) {
                            RETURN_IMPLICIT(q);
                            return DefaultYAMLParser.YAML_PLAIN;
                        }

                        while(parser.token < parser.cursor) {
                            int nl_len = newlineLen(parser.token++);
                            if(nl_len > 0) {
                              nl_count++;
                              parser.token += (nl_len - 1);
                            }
                        }

                        if(nl_count <= 1) {
                            q.cat(' ');
                        } else {
                            for(int i = 0; i < nl_count - 1; i++) {
                                q.cat('\n');
                            }
                        }
                        break;
                    }
            case 114:
                ++parser.cursor;
                switch ((yych = parser.buffer.buffer[parser.cursor])) {
                case '\n':    {gotoPoint = 141; continue gotoNext;}
                default:    {gotoPoint = 115; continue gotoNext;}
                }
            case 115:
                {
                        q.cat(parser.buffer.buffer, parser.token, parser.cursor - parser.token);
                        break;
                    }
            case 116:
                yyaccept = 1;
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                switch (yych) {
                case '\n':    {gotoPoint = 136; continue gotoNext;}
                case '\r':    {gotoPoint = 140; continue gotoNext;}
                case ' ':    {gotoPoint = 138; continue gotoNext;}
                default:    {gotoPoint = 115; continue gotoNext;}
                }
            case 117:
                yyaccept = 1;
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                switch (yych) {
                case '\n':    {gotoPoint = 130; continue gotoNext;}
                case '\r':    {gotoPoint = 134; continue gotoNext;}
                case ' ':    {gotoPoint = 132; continue gotoNext;}
                default:    {gotoPoint = 115; continue gotoNext;}
                }
            case 118:
                ++parser.cursor;
                {   
                        if(plvl.status != LevelStatus.imap) {
                            // PLAIN_NOT_INL
                            if(parser.buffer.buffer[parser.cursor-1] == ' ' || isNewline(parser.cursor-1) > 0) {
                                parser.cursor--;
                            }
                            q.cat(parser.buffer.buffer, parser.token, parser.cursor - parser.token);
                        } else {
                            q.plain_is_inl();
                            RETURN_IMPLICIT(q);
                            return DefaultYAMLParser.YAML_PLAIN;
                        }
                        break;
                    }
            case 120:
                ++parser.cursor;
                {
                        if(plvl.status != LevelStatus.iseq) {
                            // PLAIN_NOT_INL
                            if(parser.buffer.buffer[parser.cursor-1] == ' ' || isNewline(parser.cursor-1) > 0) {
                                parser.cursor--;
                            }
                            q.cat(parser.buffer.buffer, parser.token, parser.cursor - parser.token);
                        } else {
                            q.plain_is_inl();
                            RETURN_IMPLICIT(q);
                            return DefaultYAMLParser.YAML_PLAIN;
                        }
                        break;
                    }
            case 122:
                ++parser.cursor;
                switch ((yych = parser.buffer.buffer[parser.cursor])) {
                case '#':    {gotoPoint = 128; continue gotoNext;}
                default:    {gotoPoint = 123; continue gotoNext;}
                }
            case 123:
                {   
                        if(q.idx != 0) {
                            plain3 = true;
                        }
                        break;
                    }
            case 124:
                ++parser.cursor;
                {   
                        RETURN_IMPLICIT(q);
                        return DefaultYAMLParser.YAML_PLAIN;
                    }
            case 126:
                yych = parser.buffer.buffer[++parser.cursor];
                {gotoPoint = 123; continue gotoNext;}
            case 127:
                yych = parser.buffer.buffer[++parser.cursor];
                {gotoPoint = 115; continue gotoNext;}
            case 128:
                ++parser.cursor;
                {   
                        eatComments(); 
                        RETURN_IMPLICIT(q);
                        return DefaultYAMLParser.YAML_PLAIN;
                    }
            case 130:
                ++parser.cursor;
            case 131:
                {  
                        if(plvl.status != LevelStatus.iseq && plvl.status != LevelStatus.imap) {
                            // PLAIN_NOT_INL
                            if(parser.buffer.buffer[parser.cursor-1] == ' ' || isNewline(parser.cursor-1) > 0) {
                                parser.cursor--;
                            }
                            q.cat(parser.buffer.buffer, parser.token, parser.cursor - parser.token);
                        } else {
                            q.plain_is_inl();
                            RETURN_IMPLICIT(q);
                            return DefaultYAMLParser.YAML_PLAIN;
                        }

                        break;
                    }
            case 132:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case ' ':    {gotoPoint = 132; continue gotoNext;}
                default:    {gotoPoint = 131; continue gotoNext;}
                }
            case 134:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 130; continue gotoNext;}
                default:    {gotoPoint = 135; continue gotoNext;}
                }
            case 135:
                parser.cursor = parser.marker;
                if (yyaccept == 0) {
                    {gotoPoint = 113; continue gotoNext;}
                } else {
                    {gotoPoint = 115; continue gotoNext;}
                }
            case 136:
                ++parser.cursor;
            case 137:
                {   
                        RETURN_IMPLICIT(q);
                        return DefaultYAMLParser.YAML_PLAIN;
                    }
            case 138:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case ' ':    {gotoPoint = 138; continue gotoNext;}
                default:    {gotoPoint = 137; continue gotoNext;}
                }
            case 140:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 136; continue gotoNext;}
                default:    {gotoPoint = 135; continue gotoNext;}
                }
            case 141:
                yyaccept = 0;
                parser.marker = ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
            case 142:
                switch (yych) {
                case '\n':
                case ' ':    {gotoPoint = 141; continue gotoNext;}
                case '\r':    {gotoPoint = 143; continue gotoNext;}
                default:    {gotoPoint = 113; continue gotoNext;}
                }
            case 143:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 141; continue gotoNext;}
                default:    {gotoPoint = 135; continue gotoNext;}
                }
            }
        }


//               if(!plain3) {
//                  System.out.println("plain2()");
//               } else {
//                  System.out.println("plain3()");
//               }
           } while(plain3);
       }
   }

   private int doubleQuote() throws java.io.IOException {
//        System.out.println("doubleQuote()");
       int keep_nl = 1;
       QuotedString q = new QuotedString();
       while(true) {
           parser.token = parser.cursor;

        int gotoPoint = -1;
        byte yych = (byte) 0;
        int yyaccept = 0;
        gotoNext: while(gotoPoint != -2) {
            int currentGoto = gotoPoint; gotoPoint = -2;
            switch(currentGoto) {
            case -1: 
                if ((parser.limit - parser.cursor) < 4) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case 0x00:    {gotoPoint = 151; continue gotoNext;}
                case '\n':    {gotoPoint = 146; continue gotoNext;}
                case '\r':    {gotoPoint = 148; continue gotoNext;}
                case '"':    {gotoPoint = 153; continue gotoNext;}
                case '\\':    {gotoPoint = 150; continue gotoNext;}
                default:    {gotoPoint = 154; continue gotoNext;}
                }
            case 146:
                yyaccept = 0;
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                {gotoPoint = 168; continue gotoNext;}
            case 147:
                {
                        // GOBBLE_UP_YAML_INDENT( indt_len, YYTOKEN )
                        int indent = parser.token;
                        NEWLINE(indent);
                        while(indent < parser.cursor) {
                            // these pieces commented out to be compatible with Syck 0.60. 
//                          if(parser.buffer.buffer[indent] == '\t') {
//                            error("TAB found in your indentation, please remove",parser);
//                          } else if(isNewline(++indent) != 0) {
//                            NEWLINE(indent);
//                          }

                          if(isNewline(++indent) != 0) {
                            NEWLINE(indent);
                          }
                        }
                        int indt_len = 0;
                        if(parser.buffer.buffer[parser.cursor] == 0) {
                          indt_len = -1;
                          parser.token = parser.cursor-1;
                        } else if(parser.buffer.buffer[parser.lineptr] == ' ') {
                          indt_len = parser.cursor - parser.lineptr;
                        }

                        int nl_count = 0;
                        Level lvl = parser.currentLevel();
                        if(lvl.status != LevelStatus.str) {
                            parser.addLevel(indt_len, LevelStatus.str);
                        } else if(indt_len < lvl.spaces) {
                            // Error!
                        }

                        if(keep_nl == 1) {
                            while(parser.token < parser.cursor) {
                                int nl_len = newlineLen(parser.token++);
                                if(nl_len > 0) {
                                    nl_count++;
                                    parser.token += (nl_len - 1);
                                }
                            }
                            if(nl_count <= 1) {
                                q.cat(' ');
                            } else {
                                for(int i = 0; i < nl_count - 1; i++) {
                                    q.cat('\n');
                                }
                            }
                        }

                        keep_nl = 1;
                        break;
                    }
            case 148:
                ++parser.cursor;
                switch ((yych = parser.buffer.buffer[parser.cursor])) {
                case '\n':    {gotoPoint = 167; continue gotoNext;}
                default:    {gotoPoint = 149; continue gotoNext;}
                }
            case 149:
                {   q.cat(parser.buffer.buffer[parser.cursor-1]);
                        break;
                    }
            case 150:
                yyaccept = 1;
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                switch (yych) {
                case '\n':    {gotoPoint = 158; continue gotoNext;}
                case '\r':    {gotoPoint = 160; continue gotoNext;}
                case ' ':    {gotoPoint = 155; continue gotoNext;}
                case '"':
                case '0':
                case '\\':
                case 'a':
                case 'b':
                case 'e':
                case 'f':
                case 'n':
                case 'r':
                case 't':
                case 'v':    {gotoPoint = 162; continue gotoNext;}
                case 'x':    {gotoPoint = 161; continue gotoNext;}
                default:    {gotoPoint = 149; continue gotoNext;}
                }
            case 151:
                ++parser.cursor;
            case 152:
                {   
                        Node n = Node.allocStr();
                        Level lvl = parser.currentLevel();

                        if(lvl.status == LevelStatus.str) {
                            parser.popLevel();
                        }

                        if(parser.taguri_expansion) {
                            n.type_id = Parser.taguri(YAML.DOMAIN, "str");
                        } else {
                            n.type_id = "str";
                        }
                        Data.Str dd = (Data.Str)n.data;
                        dd.ptr = Pointer.create(q.str, 0);
                        dd.len = q.idx;
                        dd.style = ScalarStyle.TwoQuote;
                        lval = n;
                        return DefaultYAMLParser.YAML_PLAIN;
                    }
            case 153:
                yych = parser.buffer.buffer[++parser.cursor];
                {gotoPoint = 152; continue gotoNext;}
            case 154:
                yych = parser.buffer.buffer[++parser.cursor];
                {gotoPoint = 149; continue gotoNext;}
            case 155:
                ++parser.cursor;
                if ((parser.limit - parser.cursor) < 2) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 158; continue gotoNext;}
                case '\r':    {gotoPoint = 160; continue gotoNext;}
                case ' ':    {gotoPoint = 155; continue gotoNext;}
                default:    {gotoPoint = 157; continue gotoNext;}
                }
            case 157:
                parser.cursor = parser.marker;
                if (yyaccept == 0) {
                    {gotoPoint = 147; continue gotoNext;}
                } else {
                    {gotoPoint = 149; continue gotoNext;}
                }
            case 158:
                ++parser.cursor;
                {   keep_nl = 0;
                        parser.cursor--;
                        break;
                    }
            case 160:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 158; continue gotoNext;}
                default:    {gotoPoint = 157; continue gotoNext;}
                }
            case 161:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':    {gotoPoint = 164; continue gotoNext;}
                default:    {gotoPoint = 157; continue gotoNext;}
                }
            case 162:
                ++parser.cursor;
                {   
                        byte ch = parser.buffer.buffer[parser.cursor-1];
                        q.cat(escapeSeq(ch));
                        break;
                    }
            case 164:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':    {gotoPoint = 165; continue gotoNext;}
                default:    {gotoPoint = 157; continue gotoNext;}
                }
            case 165:
                ++parser.cursor;
                {    
                        q.cat((byte)Integer.valueOf(new String(parser.buffer.buffer, parser.token+2, 2, "ISO-8859-1"), 16).intValue());
                        break;
                    }
            case 167:
                yyaccept = 0;
                parser.marker = ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
            case 168:
                switch (yych) {
                case '\n':
                case ' ':    {gotoPoint = 167; continue gotoNext;}
                case '\r':    {gotoPoint = 169; continue gotoNext;}
                default:    {gotoPoint = 147; continue gotoNext;}
                }
            case 169:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 167; continue gotoNext;}
                default:    {gotoPoint = 157; continue gotoNext;}
                }
            }
        }

       }
   }

   private int singleQuote() throws java.io.IOException {
//        System.out.println("singleQuote()");
       QuotedString q = new QuotedString();
       while(true) {
           parser.token = parser.cursor;

        int gotoPoint = -1;
        byte yych = (byte) 0;
        gotoNext: while(gotoPoint != -2) {
            int currentGoto = gotoPoint; gotoPoint = -2;
            switch(currentGoto) {
            case -1: 
                if ((parser.limit - parser.cursor) < 2) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case 0x00:    {gotoPoint = 178; continue gotoNext;}
                case '\n':    {gotoPoint = 172; continue gotoNext;}
                case '\r':    {gotoPoint = 174; continue gotoNext;}
                case '\'':    {gotoPoint = 176; continue gotoNext;}
                default:    {gotoPoint = 179; continue gotoNext;}
                }
            case 172:
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                {gotoPoint = 183; continue gotoNext;}
            case 173:
                {
                        // GOBBLE_UP_YAML_INDENT( indt_len, YYTOKEN )
                        int indent = parser.token;
                        NEWLINE(indent);
                        while(indent < parser.cursor) {
                            // these pieces commented out to be compatible with Syck 0.60. 
//                          if(parser.buffer.buffer[indent] == '\t') {
//                            error("TAB found in your indentation, please remove",parser);
//                          } else if(isNewline(++indent) != 0) {
//                            NEWLINE(indent);
//                          }

                          if(isNewline(++indent) != 0) {
                            NEWLINE(indent);
                          }
                        }
                        int indt_len = 0;
                        if(parser.buffer.buffer[parser.cursor] == 0) {
                          indt_len = -1;
                          parser.token = parser.cursor-1;
                        } else if(parser.buffer.buffer[parser.lineptr] == ' ') {
                          indt_len = parser.cursor - parser.lineptr;
                        }

                        int nl_count = 0;
                        Level lvl = parser.currentLevel();
                        if(lvl.status != LevelStatus.str) {
                            parser.addLevel(indt_len, LevelStatus.str);
                        } else if(indt_len < lvl.spaces) {
                            // Error!
                        }

                        while(parser.token < parser.cursor) {
                          int nl_len = newlineLen(parser.token++);
                          if(nl_len > 0) {
                            nl_count++;
                            parser.token += (nl_len - 1);
                          }
                        }
                        if(nl_count <= 1) {
                            q.cat(' ');
                        } else {
                            for(int i = 0; i < nl_count - 1; i++) {
                                q.cat('\n');
                            }
                        }
                        break;
                    }
            case 174:
                ++parser.cursor;
                switch ((yych = parser.buffer.buffer[parser.cursor])) {
                case '\n':    {gotoPoint = 182; continue gotoNext;}
                default:    {gotoPoint = 175; continue gotoNext;}
                }
            case 175:
                {   q.cat(parser.buffer.buffer[parser.cursor-1]);
                        break;
                    }
            case 176:
                ++parser.cursor;
                switch ((yych = parser.buffer.buffer[parser.cursor])) {
                case '\'':    {gotoPoint = 180; continue gotoNext;}
                default:    {gotoPoint = 177; continue gotoNext;}
                }
            case 177:
                {   
                        Node n = Node.allocStr();
                        Level lvl = parser.currentLevel();
                        if(lvl.status == LevelStatus.str) {
                            parser.popLevel();
                        }
                        if(parser.taguri_expansion) {
                            n.type_id = Parser.taguri(YAML.DOMAIN, "str");
                        } else {
                            n.type_id = "str";
                        }
                        Data.Str dd = (Data.Str)n.data;
                        dd.ptr = Pointer.create(q.str, 0);
                        dd.len = q.idx;
                        dd.style = ScalarStyle.OneQuote;
                        lval = n;
                        return DefaultYAMLParser.YAML_PLAIN; 
                    }
            case 178:
                yych = parser.buffer.buffer[++parser.cursor];
                {gotoPoint = 177; continue gotoNext;}
            case 179:
                yych = parser.buffer.buffer[++parser.cursor];
                {gotoPoint = 175; continue gotoNext;}
            case 180:
                ++parser.cursor;
                {   q.cat('\'');
                        break;
                    }
            case 182:
                parser.marker = ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
            case 183:
                switch (yych) {
                case '\n':
                case ' ':    {gotoPoint = 182; continue gotoNext;}
                case '\r':    {gotoPoint = 184; continue gotoNext;}
                default:    {gotoPoint = 173; continue gotoNext;}
                }
            case 184:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 182; continue gotoNext;}
                default:    {gotoPoint = 185; continue gotoNext;}
                }
            case 185:
                parser.cursor = parser.marker;
                {gotoPoint = 173; continue gotoNext;}
            }
        }

       }
   }

   private int transferMethod() throws java.io.IOException {
//        System.out.println("transferMethod()");
       QuotedString q = new QuotedString();
       while(true) {
           parser.toktmp = parser.cursor;

        int gotoPoint = -1;
        byte yych = (byte) 0;
        gotoNext: while(gotoPoint != -2) {
            int currentGoto = gotoPoint; gotoPoint = -2;
            switch(currentGoto) {
            case -1: 
                if ((parser.limit - parser.cursor) < 4) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case 0x00:    {gotoPoint = 188; continue gotoNext;}
                case '\n':    {gotoPoint = 190; continue gotoNext;}
                case '\r':    {gotoPoint = 192; continue gotoNext;}
                case ' ':    {gotoPoint = 191; continue gotoNext;}
                case '\\':    {gotoPoint = 194; continue gotoNext;}
                default:    {gotoPoint = 195; continue gotoNext;}
                }
            case 188:
                ++parser.cursor;
            case 189:
                {   
                        parser.cursor = parser.toktmp;
                        if(parser.cursor == parser.token + 1) {
                            return DefaultYAMLParser.YAML_ITRANSFER;
                        }

                        Level lvl = parser.currentLevel();

                        /*
                         * URL Prefixing
                         */
                        if(q.str[0] == '^') {
                            lval = lvl.domain + new String(q.str, 1, q.idx - 1, "ISO-8859-1");
                        } else {
                            int carat = 0;
                            int qend = q.idx;
                            while((++carat) < qend) {
                              if(q.str[carat] == '^') {
                                break;
                              }
                            }

                            if(carat < qend) {
                                lvl.domain = new String(q.str, 0, carat, "ISO-8859-1");
                                lval = lvl.domain + new String(q.str, carat + 1, (qend - carat) - 1, "ISO-8859-1");
                            } else {
                                lval = new String(q.str, 0, qend, "ISO-8859-1");
                            }
                        }

                        return DefaultYAMLParser.YAML_TRANSFER; 
                    }
            case 190:
                yych = parser.buffer.buffer[++parser.cursor];
                {gotoPoint = 189; continue gotoNext;}
            case 191:
                yych = parser.buffer.buffer[++parser.cursor];
                {gotoPoint = 204; continue gotoNext;}
            case 192:
                ++parser.cursor;
                switch ((yych = parser.buffer.buffer[parser.cursor])) {
                case '\n':    {gotoPoint = 188; continue gotoNext;}
                default:    {gotoPoint = 193; continue gotoNext;}
                }
            case 193:
                {   
                        q.cat(parser.buffer.buffer[parser.cursor-1]);
                        break;
                    }
            case 194:
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                switch (yych) {
                case '"':
                case '0':
                case '\\':
                case 'a':
                case 'b':
                case 'e':
                case 'f':
                case 'n':
                case 'r':
                case 't':
                case 'v':    {gotoPoint = 198; continue gotoNext;}
                case 'x':    {gotoPoint = 196; continue gotoNext;}
                default:    {gotoPoint = 193; continue gotoNext;}
                }
            case 195:
                yych = parser.buffer.buffer[++parser.cursor];
                {gotoPoint = 193; continue gotoNext;}
            case 196:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':    {gotoPoint = 200; continue gotoNext;}
                default:    {gotoPoint = 197; continue gotoNext;}
                }
            case 197:
                parser.cursor = parser.marker;
                {gotoPoint = 193; continue gotoNext;}
            case 198:
                ++parser.cursor;
                {  
                        byte ch = parser.buffer.buffer[parser.cursor-1];
                        q.cat(escapeSeq(ch));
                        break;
                    }
            case 200:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':    {gotoPoint = 201; continue gotoNext;}
                default:    {gotoPoint = 197; continue gotoNext;}
                }
            case 201:
                ++parser.cursor;
                {   
                        q.cat((byte)Integer.valueOf(new String(parser.buffer.buffer, parser.toktmp+2, 2, "ISO-8859-1"), 16).intValue());
                        break;
                    }
            case 203:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
            case 204:
                switch (yych) {
                case ' ':    {gotoPoint = 203; continue gotoNext;}
                default:    {gotoPoint = 189; continue gotoNext;}
                }
            }
        }

       }
   }

   private int scalarBlock() throws java.io.IOException {
//        System.out.println("scalarBlock()");
       QuotedString q = new QuotedString();
       q.str[0] = 0;

       int lastIndent = 0;
       int parentIndent = -1;
       int blockType = 0;
       int nlDoWhat = 0;
       int forceIndent = -1;
       int yyt = parser.token;
       Level lvl = parser.currentLevel();

       switch(parser.buffer.buffer[yyt]) {
           case '|': blockType = YAML.BLOCK_LIT; break;
           case '>': blockType = YAML.BLOCK_FOLD; break;
       }

       while( ++yyt <= parser.cursor ) {
           if(parser.buffer.buffer[yyt] == '-') {
               nlDoWhat = YAML.NL_CHOMP;
           } else if(parser.buffer.buffer[yyt] == '+' ) {
               nlDoWhat = YAML.NL_KEEP;
           } else if(Character.isDigit((char)parser.buffer.buffer[yyt])) {
               forceIndent = (char)parser.buffer.buffer[yyt] - '0';
           }
       }

       while(true) {
           parser.token = parser.cursor;

        int gotoPoint = -1;
        byte yych = (byte) 0;
        int yyaccept = 0;
        gotoNext: while(gotoPoint != -2) {
            int currentGoto = gotoPoint; gotoPoint = -2;
            switch(currentGoto) {
            case -1: 
                if ((parser.limit - parser.cursor) < 5) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case 0x00:    {gotoPoint = 213; continue gotoNext;}
                case '\n':    {gotoPoint = 207; continue gotoNext;}
                case '\r':    {gotoPoint = 209; continue gotoNext;}
                case '#':    {gotoPoint = 211; continue gotoNext;}
                case '-':    {gotoPoint = 215; continue gotoNext;}
                default:    {gotoPoint = 216; continue gotoNext;}
                }
            case 207:
                yyaccept = 0;
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                {gotoPoint = 226; continue gotoNext;}
            case 208:
                {   
                        int tok = parser.token;
                        int nl_count = 0, fold_nl = 0, nl_begin = 0;

                        int indent = tok;
                        NEWLINE(indent);
                        while(indent < parser.cursor) {
                            // these pieces commented out to be compatible with Syck 0.60. 
//                          if(parser.buffer.buffer[indent] == '\t') {
//                            error("TAB found in your indentation, please remove",parser);
//                          } else if(isNewline(++indent) != 0) {
//                            NEWLINE(indent);
//                          }

                          if(isNewline(++indent) != 0) {
                            NEWLINE(indent);
                          }
                        }
                        int indt_len = 0;
                        if(parser.buffer.buffer[parser.cursor] == 0) {
                          indt_len = -1;
                          tok = parser.cursor-1;
                        } else if(parser.buffer.buffer[parser.lineptr] == ' ') {
                          indt_len = parser.cursor - parser.lineptr;
                        }

                        lvl = parser.currentLevel();
                        if(lvl.status != LevelStatus.block) {
                            parentIndent = GET_TRUE_YAML_INDENT();
                            if(forceIndent > 0) forceIndent += parentIndent;
                            if(indt_len > parentIndent) {
                                int new_spaces = forceIndent > 0 ? forceIndent : indt_len;
                                parser.addLevel(new_spaces, LevelStatus.block);
                                lastIndent = indt_len - new_spaces;
                                nl_begin = 1;
                                lvl = parser.currentLevel();
                            } else {
                                parser.cursor = parser.token;
                                RETURN_YAML_BLOCK(q, blockType, nlDoWhat);
                                return DefaultYAMLParser.YAML_BLOCK;
                            }
                        }

                        /*
                         * Fold only in the event of two lines being on the leftmost
                         * indentation.
                         */
                        if(blockType == YAML.BLOCK_FOLD && lastIndent == 0 && (indt_len - lvl.spaces) == 0) {
                            fold_nl = 1;
                        }

                        int pacer = parser.token;
                        while(pacer < parser.cursor) {
                            int nl_len = newlineLen(pacer++);
                            if(nl_len>0) {
                                nl_count++;
                                pacer += (nl_len - 1);
                            }
                        }

                        if(fold_nl == 1 || nl_begin == 1) {
                            nl_count--;
                        }

                        if(nl_count < 1 && nl_begin == 0) {
                            q.cat(' ');
                        } else {
                            for(int i = 0; i < nl_count; i++) {
                                q.cat('\n');
                            }
                        }

                        lastIndent = indt_len - lvl.spaces;
                        parser.cursor -= lastIndent;

                        if(indt_len < lvl.spaces) {
                            parser.popLevel();
                            parser.cursor = parser.token;
                            RETURN_YAML_BLOCK(q, blockType, nlDoWhat);
                            return DefaultYAMLParser.YAML_BLOCK;
                        }
                        break;
                    }
            case 209:
                ++parser.cursor;
                switch ((yych = parser.buffer.buffer[parser.cursor])) {
                case '\n':    {gotoPoint = 225; continue gotoNext;}
                default:    {gotoPoint = 210; continue gotoNext;}
                }
            case 210:
                {   q.cat(parser.buffer.buffer[parser.token]);
                        break;
                    }
            case 211:
                ++parser.cursor;
                {   lvl = parser.currentLevel();
                        if(lvl.status != LevelStatus.block) {
                            eatComments();
                            parser.token = parser.cursor;
                        } else {
                            q.cat(parser.buffer.buffer[parser.token]);
                        }
                        break;
                    }
            case 213:
                ++parser.cursor;
                {   parser.cursor--;
                        parser.popLevel();
                        RETURN_YAML_BLOCK(q, blockType, nlDoWhat); 
                        return DefaultYAMLParser.YAML_BLOCK;
                    }
            case 215:
                yyaccept = 1;
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                switch (yych) {
                case '-':    {gotoPoint = 217; continue gotoNext;}
                default:    {gotoPoint = 210; continue gotoNext;}
                }
            case 216:
                yych = parser.buffer.buffer[++parser.cursor];
                {gotoPoint = 210; continue gotoNext;}
            case 217:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '-':    {gotoPoint = 219; continue gotoNext;}
                default:    {gotoPoint = 218; continue gotoNext;}
                }
            case 218:
                parser.cursor = parser.marker;
                if (yyaccept == 0) {
                    {gotoPoint = 208; continue gotoNext;}
                } else {
                    {gotoPoint = 210; continue gotoNext;}
                }
            case 219:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 220; continue gotoNext;}
                case '\r':    {gotoPoint = 224; continue gotoNext;}
                case ' ':    {gotoPoint = 222; continue gotoNext;}
                default:    {gotoPoint = 218; continue gotoNext;}
                }
            case 220:
                ++parser.cursor;
            case 221:
                {   if(parser.token == parser.lineptr) {
                            if(blockType == YAML.BLOCK_FOLD && q.idx > 0) {
                                q.idx--;
                            }
                            q.cat('\n');
                            parser.popLevel();
                            parser.cursor = parser.token;
                            RETURN_YAML_BLOCK(q, blockType, nlDoWhat);
                            return DefaultYAMLParser.YAML_BLOCK;
                        } else {
                            q.cat(parser.buffer.buffer[parser.token]);
                            parser.cursor = parser.token + 1;
                        }
                        break;
                    }
            case 222:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case ' ':    {gotoPoint = 222; continue gotoNext;}
                default:    {gotoPoint = 221; continue gotoNext;}
                }
            case 224:
                yych = parser.buffer.buffer[++parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 220; continue gotoNext;}
                default:    {gotoPoint = 218; continue gotoNext;}
                }
            case 225:
                yyaccept = 0;
                parser.marker = ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
            case 226:
                switch (yych) {
                case '\n':
                case ' ':    {gotoPoint = 225; continue gotoNext;}
                case '\r':    {gotoPoint = 227; continue gotoNext;}
                default:    {gotoPoint = 208; continue gotoNext;}
                }
            case 227:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 225; continue gotoNext;}
                default:    {gotoPoint = 218; continue gotoNext;}
                }
            }
        }

       }
   }

   private byte escapeSeq(byte ch) {
       switch(ch) {
        case '0': return '\0';
        case 'a': return 7;
        case 'b': return '\010';
        case 'e': return '\033';
        case 'f': return '\014';
        case 'n': return '\n';
        case 'r': return '\015';
        case 't': return '\t';
        case 'v': return '\013';
        default: return ch;
      }
   }

   private void eatComments() throws IOException {
     while(true) {
       parser.token = parser.cursor;

        int gotoPoint = -1;
        byte yych = (byte) 0;
        gotoNext: while(gotoPoint != -2) {
            int currentGoto = gotoPoint; gotoPoint = -2;
            switch(currentGoto) {
            case -1: 
                if ((parser.limit - parser.cursor) < 2) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case 0x00:    {gotoPoint = 230; continue gotoNext;}
                case '\n':    {gotoPoint = 232; continue gotoNext;}
                case '\r':    {gotoPoint = 233; continue gotoNext;}
                default:    {gotoPoint = 235; continue gotoNext;}
                }
            case 230:
                ++parser.cursor;
            case 231:
                {   parser.cursor = parser.token;
                        return;
                    }
            case 232:
                yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                {gotoPoint = 237; continue gotoNext;}
            case 233:
                ++parser.cursor;
                switch ((yych = parser.buffer.buffer[parser.cursor])) {
                case '\n':    {gotoPoint = 236; continue gotoNext;}
                default:    {gotoPoint = 234; continue gotoNext;}
                }
            case 234:
                { break; }
            case 235:
                yych = parser.buffer.buffer[++parser.cursor];
                {gotoPoint = 234; continue gotoNext;}
            case 236:
                parser.marker = ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
            case 237:
                switch (yych) {
                case '\n':    {gotoPoint = 236; continue gotoNext;}
                case '\r':    {gotoPoint = 238; continue gotoNext;}
                default:    {gotoPoint = 231; continue gotoNext;}
                }
            case 238:
                ++parser.cursor;
                if (parser.limit <= parser.cursor) parser.read();
                yych = parser.buffer.buffer[parser.cursor];
                switch (yych) {
                case '\n':    {gotoPoint = 236; continue gotoNext;}
                default:    {gotoPoint = 239; continue gotoNext;}
                }
            case 239:
                parser.cursor = parser.marker;
                {gotoPoint = 231; continue gotoNext;}
            }
        }

    }
  }
}
