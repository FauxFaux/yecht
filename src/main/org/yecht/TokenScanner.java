/* Generated by re2j 0.13.6.dev on Mon Jul 13 15:05:41 2009 */
package org.yecht;

import java.io.IOException;

// Equivalent to token.re
public class TokenScanner implements YAMLGrammarTokens, Scanner {
   private Parser parser;

   private Object lval;
   private int currentToken = -1;

   public static void error(String msg, Parser parser) {
   }

   public static Scanner createScanner(Parser parser) {
     switch(parser.input_type) {
       case YAML_UTF8:
         return new TokenScanner(parser);
       case Bytecode_UTF8:
         // TODO: fix
         return null;
       case YAML_UTF16:
         error("UTF-16 is not currently supported in Yecht.\nPlease contribute code to help this happen!", parser);
         return null;
       case YAML_UTF32:
         error("UTF-32 is not currently supported in Yecht.\nPlease contribute code to help this happen!", parser);
         return null;
     }
     return null;
   }

   public TokenScanner(Parser parser) {
     this.parser = parser;
   }

   public Object getLVal() {
     return lval;
   }

   public int currentToken() {
     return currentToken;
   }

   public int yylex() {
     try {
          currentToken = real_yylex();
          return currentToken;
     } catch(java.io.IOException ioe) {
          throw new RuntimeException(ioe);
     }
   }


   private final static int Header = 1;
   private final static int Document = 2;
   private final static int Directive = 3;
   private final static int Plain = 4;
   private final static int Plain2 = 5;
   private final static int Plain3 = 6;
   private final static int SingleQuote = 7;
   private final static int SingleQuote2 = 8;
   private final static int DoubleQuote = 9;
   private final static int DoubleQuote2 = 10;
   private final static int TransferMethod = 11;
   private final static int TransferMethod2 = 12;
   private final static int ScalarBlock = 13;
   private final static int ScalarBlock2 = 14;

   private int real_yylex() throws IOException {
     int doc_level = 0;
     if(parser.cursor == -1) {
       parser.read();
     }

     if(parser.force_token != 0) {
       int t = parser.force_token;
       parser.force_token = 0;
       return t;
     }


        int mainLoopGoto = Header;
        do {
            gotoSomething: while(true) {
                switch(mainLoopGoto) {
                case Header:
                case Document:
                case Directive:
                case Plain:
                case Plain2:
                case Plain3:
                case SingleQuote:
                case SingleQuote2:
                case DoubleQuote:
                case DoubleQuote2:
                case TransferMethod:
                case TransferMethod2:
                case ScalarBlock:
                case ScalarBlock2:
                }
                return 0;                
            }
        } while(true);
   }

   private void eatComments() throws IOException {
     comment: while(true) {
       parser.token = parser.cursor;

        int gotoPoint = -1;
        byte yych = (byte) 0;
        while(true) {
            gotoNext: while(true) {
                switch(gotoPoint) {
                case -1: 

                    if ((parser.limit - parser.cursor) < 2) parser.read();
                    yych = parser.buffer.buffer[parser.cursor];
                    switch (yych) {
                    case 0x00:    gotoPoint = 2; break gotoNext;
                    case '\n':    gotoPoint = 4; break gotoNext;
                    case '\r':    gotoPoint = 5; break gotoNext;
                    default:    gotoPoint = 7; break gotoNext;
                    }
                case 2:
                    ++parser.cursor;
                case 3:
                    {   parser.cursor = parser.token;
                        return;
                    }
                case 4:
                    yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                    gotoPoint = 9; break gotoNext;
                case 5:
                    ++parser.cursor;
                    switch ((yych = parser.buffer.buffer[parser.cursor])) {
                    case '\n':    gotoPoint = 8; break gotoNext;
                    default:    gotoPoint = 6; break gotoNext;
                    }
                case 6:
                    {   continue comment; 
                    }
                case 7:
                    yych = parser.buffer.buffer[++parser.cursor];
                    gotoPoint = 6; break gotoNext;
                case 8:
                    parser.marker = ++parser.cursor;
                    if (parser.limit <= parser.cursor) parser.read();
                    yych = parser.buffer.buffer[parser.cursor];
                case 9:
                    switch (yych) {
                    case '\n':    gotoPoint = 8; break gotoNext;
                    case '\r':    gotoPoint = 10; break gotoNext;
                    default:    gotoPoint = 3; break gotoNext;
                    }
                case 10:
                    ++parser.cursor;
                    if (parser.limit <= parser.cursor) parser.read();
                    yych = parser.buffer.buffer[parser.cursor];
                    switch (yych) {
                    case '\n':    gotoPoint = 8; break gotoNext;
                    default:    gotoPoint = 11; break gotoNext;
                    }
                case 11:
                    parser.cursor = parser.marker;
                    gotoPoint = 3; break gotoNext;
                }
            }
        }

    }
  }
}
