/* Generated by re2j 0.13.6.dev on Tue Jul 14 19:15:35 2009 */
package org.yecht;

import java.io.IOException;

// Equivalent to bytecode.re
public class BytecodeScanner implements YAMLGrammarTokens, Scanner {
   public final static int QUOTELEN = 128;
   private Parser parser;

   private Object lval;
   private int currentToken = -1;

   public BytecodeScanner(Parser parser) {
     this.parser = parser;
   }

   public Object getLVal() {
     return lval;
   }

   public int currentToken() {
     return currentToken;
   }

   public int yylex() {
     try {
          currentToken = real_yylex();
          return currentToken;
     } catch(java.io.IOException ioe) {
          throw new RuntimeException(ioe);
     }
   }

   private void YYPOS(int n) {
       parser.cursor = parser.token + n;
   }

   private void FORCE_NEXT_TOKEN(int n) {
       parser.force_token = n;
   }

   private void CHK_NL(int ptr) {
       if(parser.buffer.buffer[ptr - 1] == '\n' && ptr > parser.linectptr) {
           parser.lineptr = ptr;
           parser.linect++;
           parser.linectptr = parser.lineptr;
       }
   }

   private boolean ADD_BYTE_LEVEL(Level lvl, int len, LevelStatus s) {
       switch(lvl.status) {
           case seq:
               lvl.ncount++;
               parser.addLevel(len, LevelStatus.open);
               YYPOS(0);
               return true;
           case map:
               lvl.ncount++;
               parser.addLevel(len, s);
               return false;
           case open:
               lvl.status = s;
               return false;
           default:
               parser.addLevel(len, s);
               return false;
       }
   }

   private final static int Start = 1;
   private final static int Document = 2;
   private final static int Directive = 3;
   private final static int Comment = 4;
   private final static int Scalar = 5;
   private final static int Scalar2 = 6;
   private final static int ScalarEnd = 7;

   // sycklex_bytecode_utf8
   private int real_yylex() throws IOException {
       Level lvl = null;
       if(parser.cursor == -1) {
           parser.read();
       }

       if(parser.force_token != 0) {
           int t = parser.force_token;
           parser.force_token = 0;
           return t;
       }


       int mainLoopGoto = Start;
       lvl = parser.currentLevel();
       if(lvl.status == LevelStatus.doc) {
           mainLoopGoto = Document;
       }

       parser.token = parser.cursor;
       {

        int gotoPoint = -1;
        byte yych = (byte) 0;
        re2jgetout: while(true) {
            gotoNext: while(true) {
                switch(gotoPoint) {
                case -1: 

                    if ((parser.limit - parser.cursor) < 3) parser.read();
                    yych = parser.buffer.buffer[parser.cursor];
                    switch (yych) {
                    case 0x00:    {gotoPoint = 2; break gotoNext;}
                    case 'D':    {gotoPoint = 3; break gotoNext;}
                    default:    {gotoPoint = 5; break gotoNext;}
                    }
                case 2:
                    parser.cursor = parser.marker;
                    {gotoPoint = 4; break gotoNext;}
                case 3:
                    yych = parser.buffer.buffer[(parser.marker = ++parser.cursor)];
                    switch (yych) {
                    case '\n':    {gotoPoint = 6; break gotoNext;}
                    case '\r':    {gotoPoint = 8; break gotoNext;}
                    default:    {gotoPoint = 4; break gotoNext;}
                    }
                case 4:
                    {   YYPOS(0);
            mainLoopGoto = Document;
        }
                case 5:
                    yych = parser.buffer.buffer[++parser.cursor];
                    {gotoPoint = 4; break gotoNext;}
                case 6:
                    ++parser.cursor;
                    {   if(lvl.status == LevelStatus.header) {
                CHK_NL(parser.cursor);
                mainLoopGoto = Directive;
            } else  {
                if(lvl.spaces > -1) {
                    parser.popLevel();
                    YYPOS(0);
                    return YAML_IEND;
                }
                YYPOS(0);
                return 0;
            }
        }
                case 8:
                    ++parser.cursor;
                    switch ((yych = parser.buffer.buffer[parser.cursor])) {
                    case '\n':    {gotoPoint = 6; break gotoNext;}
                    default:    {gotoPoint = 2; break gotoNext;}
                    }
                }
            break re2jgetout;}
        }

       }

       do {
           gotoSomething: while(true) {
               switch(mainLoopGoto) {
               case Start: {
               }
               case Document: {
                   lvl = parser.currentLevel();
                   if(lvl.status == LevelStatus.header) {
                       lvl.status = LevelStatus.doc;
                   }
                   parser.token = parser.cursor;


        int gotoPoint = -1;
        byte yych = (byte) 0;
        re2jgetout: while(true) {
            gotoNext: while(true) {
                switch(gotoPoint) {
                case -1: 
                    if ((parser.limit - parser.cursor) < 3) parser.read();
                    yych = parser.buffer.buffer[parser.cursor];
                    switch (yych) {
                    case 0x00:    {gotoPoint = 30; break gotoNext;}
                    case '\n':    {gotoPoint = 27; break gotoNext;}
                    case '\r':    {gotoPoint = 29; break gotoNext;}
                    case 'A':    {gotoPoint = 19; break gotoNext;}
                    case 'D':    {gotoPoint = 12; break gotoNext;}
                    case 'E':    {gotoPoint = 16; break gotoNext;}
                    case 'M':    {gotoPoint = 14; break gotoNext;}
                    case 'P':    {gotoPoint = 13; break gotoNext;}
                    case 'Q':    {gotoPoint = 15; break gotoNext;}
                    case 'R':    {gotoPoint = 21; break gotoNext;}
                    case 'S':    {gotoPoint = 17; break gotoNext;}
                    case 'T':    {gotoPoint = 23; break gotoNext;}
                    case 'c':    {gotoPoint = 25; break gotoNext;}
                    default:    {gotoPoint = 11; break gotoNext;}
                    }
                case 11:
                case 12:
                    yych = parser.buffer.buffer[++parser.cursor];
                    switch (yych) {
                    case '\n':    {gotoPoint = 41; break gotoNext;}
                    case '\r':    {gotoPoint = 44; break gotoNext;}
                    default:    {gotoPoint = 11; break gotoNext;}
                    }
                case 13:
                    yych = parser.buffer.buffer[++parser.cursor];
                    switch (yych) {
                    case '\n':    {gotoPoint = 41; break gotoNext;}
                    case '\r':    {gotoPoint = 43; break gotoNext;}
                    default:    {gotoPoint = 11; break gotoNext;}
                    }
                case 14:
                    yych = parser.buffer.buffer[++parser.cursor];
                    switch (yych) {
                    case '\n':    {gotoPoint = 38; break gotoNext;}
                    case '\r':    {gotoPoint = 40; break gotoNext;}
                    default:    {gotoPoint = 11; break gotoNext;}
                    }
                case 15:
                    yych = parser.buffer.buffer[++parser.cursor];
                    switch (yych) {
                    case '\n':    {gotoPoint = 35; break gotoNext;}
                    case '\r':    {gotoPoint = 37; break gotoNext;}
                    default:    {gotoPoint = 11; break gotoNext;}
                    }
                case 16:
                    yych = parser.buffer.buffer[++parser.cursor];
                    switch (yych) {
                    case '\n':    {gotoPoint = 32; break gotoNext;}
                    case '\r':    {gotoPoint = 34; break gotoNext;}
                    default:    {gotoPoint = 11; break gotoNext;}
                    }
                case 17:
                    ++parser.cursor;
                    {   if(ADD_BYTE_LEVEL(lvl, lvl.spaces + 1, LevelStatus.str)) {
                return '-';
            }
            mainLoopGoto = Scalar; break gotoSomething;
        }
                case 19:
                    ++parser.cursor;
                    {   if(ADD_BYTE_LEVEL(lvl, lvl.spaces + 1, LevelStatus.open)) {
                return '-';
            }
            lval = getInline();
            parser.removeAnchor((String)lval);
            CHK_NL(parser.cursor);
            return YAML_ANCHOR;
        }
                case 21:
                    ++parser.cursor;
                    {   if(ADD_BYTE_LEVEL(lvl, lvl.spaces + 1, LevelStatus.str)) {
                return '-';
            }
            lval = getInline();
            parser.popLevel();
            if( parser.buffer.buffer[parser.cursor - 1] == '\n') parser.cursor--;
            return YAML_ALIAS;
        }
                case 23:
                    ++parser.cursor;
                    {   
            if(ADD_BYTE_LEVEL(lvl, lvl.spaces + 1, LevelStatus.open)) {
                return '-';
            }
            String qstr = getInline();
            CHK_NL(parser.cursor);
            if(qstr.charAt(0) == '!' ) {
                int qidx = qstr.length();
                if(qidx == 1) {
                    return YAML_ITRANSFER;
                }

                lvl = parser.currentLevel();

                /*
                 * URL Prefixing
                 */
                if(qstr.charAt(1) == '^') {
                    lval = lvl.domain + qstr.substring(2);
                } else {
                    int carat = qstr.indexOf('^');
                    if(carat != -1) {
                        lvl.domain = qstr.substring(1, carat);
                        lval = lvl.domain + qstr.substring(carat + 1);
                    } else {
                        lval = qstr.substring(1);
                    }
                }
                return YAML_TRANSFER;
            }
            lval = qstr;
            return YAML_TAGURI;
        }
                case 25:
                    ++parser.cursor;
                    { mainLoopGoto = Comment; break gotoSomething; }
                case 27:
                    ++parser.cursor;
                    {   CHK_NL(parser.cursor);
            if(lvl.status == LevelStatus.seq) {
                return YAML_INDENT; 
            } else if(lvl.status == LevelStatus.map) {
                if(lvl.ncount % 2 == 1) return ':';
                else                    return YAML_INDENT;
            }
            mainLoopGoto = Document; break gotoSomething;
        }
                case 29:
                    yych = parser.buffer.buffer[++parser.cursor];
                    switch (yych) {
                    case '\n':    {gotoPoint = 27; break gotoNext;}
                    default:    {gotoPoint = 11; break gotoNext;}
                    }
                case 30:
                    ++parser.cursor;
                    {   if(lvl.spaces > -1) {
                    parser.popLevel();
                    YYPOS(0);
                    return YAML_IEND;
            }
            YYPOS(0);
            return 0;
        }
                case 32:
                    ++parser.cursor;
                    {   if(lvl.status == LevelStatus.seq && lvl.ncount == 0) {
                lvl.ncount++;
                YYPOS(0);
                FORCE_NEXT_TOKEN( ']' );
                return '[';
            } else if(lvl.status == LevelStatus.map && lvl.ncount == 0) {
                lvl.ncount++;
                YYPOS(0);
                FORCE_NEXT_TOKEN( '}' );
                return '{';
            }
            parser.popLevel();
            lvl = parser.currentLevel();
            if(lvl.status == LevelStatus.seq) {
                FORCE_NEXT_TOKEN(YAML_INDENT);   
            } else if(lvl.status == LevelStatus.map) {
                if(lvl.ncount % 2 == 1) {
                    FORCE_NEXT_TOKEN(':');
                } else {
                    FORCE_NEXT_TOKEN(YAML_INDENT);
                }
            }
            CHK_NL(parser.cursor);
            return YAML_IEND;
        }
                case 34:
                    yych = parser.buffer.buffer[++parser.cursor];
                    switch (yych) {
                    case '\n':    {gotoPoint = 32; break gotoNext;}
                    default:    {gotoPoint = 11; break gotoNext;}
                    }
                case 35:
                    ++parser.cursor;
                    {   boolean complex = false;
            if(lvl.ncount % 2 == 0 && ( lvl.status == LevelStatus.map || lvl.status == LevelStatus.seq)) {
                complex = true;
            }
            if(ADD_BYTE_LEVEL(lvl, lvl.spaces + 1, LevelStatus.seq)) {
                return '-';
            }
            CHK_NL(parser.cursor);
            if(complex) {
                FORCE_NEXT_TOKEN( YAML_IOPEN );
                return '?';
            }
            return YAML_IOPEN;
        }
                case 37:
                    yych = parser.buffer.buffer[++parser.cursor];
                    switch (yych) {
                    case '\n':    {gotoPoint = 35; break gotoNext;}
                    default:    {gotoPoint = 11; break gotoNext;}
                    }
                case 38:
                    ++parser.cursor;
                    {   boolean complex = false;
            if(lvl.ncount % 2 == 0 && ( lvl.status == LevelStatus.map || lvl.status == LevelStatus.seq)) {
                complex = true;
            }
            if(ADD_BYTE_LEVEL(lvl, lvl.spaces + 1, LevelStatus.map)) {
                return '-';
            }
            CHK_NL(parser.cursor);
            if(complex) {
                FORCE_NEXT_TOKEN( YAML_IOPEN );
                return '?';
            }
            return YAML_IOPEN;
        }
                case 40:
                    yych = parser.buffer.buffer[++parser.cursor];
                    switch (yych) {
                    case '\n':    {gotoPoint = 38; break gotoNext;}
                    default:    {gotoPoint = 11; break gotoNext;}
                    }
                case 41:
                    ++parser.cursor;
                    {   if(lvl.spaces > -1) {
                    parser.popLevel();
                    YYPOS(0);
                    return YAML_IEND;
                }
                YYPOS(0);
                return 0;
            }
                case 43:
                    yych = parser.buffer.buffer[++parser.cursor];
                    switch (yych) {
                    case '\n':    {gotoPoint = 41; break gotoNext;}
                    default:    {gotoPoint = 11; break gotoNext;}
                    }
                case 44:
                    ++parser.cursor;
                    switch ((yych = parser.buffer.buffer[parser.cursor])) {
                    case '\n':    {gotoPoint = 41; break gotoNext;}
                    default:    {gotoPoint = 11; break gotoNext;}
                    }
                }
            break re2jgetout;}
        }

               }
               case Directive:
               case Comment:
               case Scalar:
               case Scalar2:
               case ScalarEnd:
               }
           }
       } while(true);
   }

   private String getInline() throws IOException {
       String str = "";
       int tok = -1;
       
       while(true) {
           tok = parser.cursor;

        int gotoPoint = -1;
        byte yych = (byte) 0;
        re2jgetout: while(true) {
            gotoNext: while(true) {
                switch(gotoPoint) {
                case -1: 
                    if ((parser.limit - parser.cursor) < 2) parser.read();
                    yych = parser.buffer.buffer[parser.cursor];
                    switch (yych) {
                    case 0x00:    {gotoPoint = 51; break gotoNext;}
                    case '\n':    {gotoPoint = 47; break gotoNext;}
                    case '\r':    {gotoPoint = 49; break gotoNext;}
                    default:    {gotoPoint = 53; break gotoNext;}
                    }
                case 47:
                    ++parser.cursor;
                case 48:
                    {   CHK_NL(parser.cursor);
                return str; }
                case 49:
                    ++parser.cursor;
                    switch ((yych = parser.buffer.buffer[parser.cursor])) {
                    case '\n':    {gotoPoint = 54; break gotoNext;}
                    default:    {gotoPoint = 50; break gotoNext;}
                    }
                case 50:
                    {   
                str = str + (char)parser.buffer.buffer[tok];
            }
                case 51:
                    ++parser.cursor;
                    {   parser.cursor = tok;
                return str;
            }
                case 53:
                    yych = parser.buffer.buffer[++parser.cursor];
                    {gotoPoint = 50; break gotoNext;}
                case 54:
                    ++parser.cursor;
                    yych = parser.buffer.buffer[parser.cursor];
                    {gotoPoint = 48; break gotoNext;}
                }
            break re2jgetout;}
        }

       }
   }
}
